-> Add sys.exit() statement instead of using variables to handle the quit event. sys.exit() throws an exception so you have to specify the try catch blocks and handle the exceptions properly.
-> Any object is blit only if it's newpos lies in the specified limits of 'VISIBLE_SCREEN_LEFT','VISIBLE_SCREEN_RIGHT','VISIBLE_SCREEN_TOP','VISIBLE_SCREEN_BOTTOM'. This will reduce the load a bit.
->Have to add a GoodImage for the screen whenever one of the display screens is active. Because the buttons are moving, you can't really achieve the half-shaded background of the game and then the buttons on that.
-> Make a file to change the settings. This file will interact with the user and take their required settings values.
->Any sprite/image/visible/invisible object has to have dimensions that are multiples of 32. 'BASE_UNIT=32' will be the main unit used throughout.
-> A small video of the 3 scientists going from a helicopter towards the island. A small cut scene showing them getting lost and each going into a ruin. A small cut scene, the protaganist gets a call to rescue them. A small cutscene to show the 3rd scientist's evil giggling.
->self.WINDOW = pygame.display.set_mod((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.RESIZABLE) ==>You have to handle the offset values because on resizing it, offset limits changes based on screen size.
-> A functionality to record and be able to play the video?
-> A zoom-out, zoom-in option. Show a small map on the bottom right corner of screen.
-> An extra "Do you want to Quit" screen to appear if the user decides to quit.(Just like the one that appears when you try to quit some movei streaming app).
##################-> Ability to move the camera with the mouse(by dragging the mouse to the end of the screen).
-> The offset mechanism has to be a bit more better.
-> When player comes to a ruin entrance in the 'Ruin0' map, the rocks should move and make way.
->All the transportation portals are to rotate at a constant speed to give it a good look 
->If the player rect is colliding with a obstacle rect, also handle the case when the player is not moving at all(i.e., handle when the player is sitting idle so that the player doesn't move at all).
->For the offset part, show a small diagram describing why the values are what they are.
->Put the sizes of the different images in their names only. This makes it easier to get the size by just using one 'parse_sizes' function to get their size.
-> Dijkstra's algorithm that the enemy can take to get to the user in case there are obstacles. This will be implemented by maintaining a list of tiles(will be empty if it's an obstacle) and the enemy calculates the shorted path to the player. This algo will always be calculated by the enemy. (If you decide to use this only when obstacle hits, then if the obstacle doesn't hit u'd go back to hitting the obstacle with the normal direction to player).